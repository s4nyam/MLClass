# -*- coding: utf-8 -*-
"""Assignment 2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ThgeMhjIQhE4KQVc5RMJoubqSikhlCVP

All Tasks:
ML ASSIGNMENT 2

1. Use Dataframe constructor in Pandas to create your own Dataframe. 

2. Print a chosen record (row) or a chosen column (data field). 

3. Print rows that satisfy a condition on one of the column entries. For example, if you create a DataFrame of players' performance in a cricket match and each record has the runs scored by the player in a cricket match, then you should be able to the print records of players who scored more than 50 runs. 
4. Also sort the records based on the number of runs scored by each player. 

5. Use vectorised operations. For example, you may be required to compute the percentage runs scored by each player, where the percentage is with respect to the total runs scored by the team in an innings. 

6. Add a new column to the Dataframe. For example, you may want to add the number written on the player's jersey. 

7. Export the Dataframe to a file in pickle format and save it as a file.  Read the pickle file back to the program. 


8. Use matplotlib library to make a scatter plot of columns that contain numeric
9. data. Provide labels to the axes. 


10. Implement linear regression to model the dependency between two variables - the predictor x and target y. You can choose any two columns in your data frame as the two variables. Print the coefficients obtained from linear regression and plot the straight line on the scatter plot.  Do not use any inbuilt function for implementing linear regression.  You need to formulate a linear system of equations and solve them using pseudo inverse.  You can compare your result with that produced by the fit() function of LinearRegression model in sklearn.

## **Task 1**
"""

#Assignment 2 by Sanyam Jain (P20QC001)

# Task 1: Use DataFrame constructor in Pandas to create your own Dataframe. 
# Dataset used - https://raw.githubusercontent.com/mwaskom/seaborn-data/master/tips.csv
# import pandas as pd
# data = {
#     'total_bill':['16.99','10.34','21.01','23.68','24.59'],
#     'tip':['1.01','1.66','3.5','3.31','3.61'],
#     'sex':['F','M','M','M','M'],
#     'smoker':['N','N','N','N','N'],
#     'day':['Sunday','Sunday','Sunday','Sunday','Sunday'],
#     'time':['Dinner','Dinner','Breakfast','Dinner','Lunch'],
#     'table_size':['2','3','3','3','4']

# }
# df=pd.DataFrame(data)
# df


import pandas as pd
data = {
    'total_bill':['16.99','10.34','21.01','23.68','24.59','25.29','8.77','26.88','15.04','14.78','10.27','35.26','15.42','18.43','14.83','21.58','10.33','16.29','16.97','20.65','17.92','20.29','15.77','39.42','19.82','17.81','13.37','12.69','21.7','19.65','9.55','18.35','15.06','20.69','17.78','24.06','16.31','16.93','18.69','31.27','16.04','17.46','13.94','9.68','30.4','18.29','22.23','32.4','28.55','18.04','12.54','10.29','34.81','9.94','25.56','19.49','38.01','26.41','11.24','48.27','20.29','13.81','11.02','18.29','17.59','20.08','16.45','3.07','20.23','15.01','12.02','17.07','26.86','25.28','14.73','10.51','17.92','27.2','22.76','17.29','19.44','16.66','10.07','32.68','15.98','34.83','13.03','18.28','24.71','21.16','28.97','22.49','5.75','16.32','22.75','40.17','27.28','12.03','21.01'],
    'tip':['1.01', '1.66', '3.5', '3.31', '3.61', '4.71', '2', '3.12', '1.96', '3.23', '1.71', '5', '1.57', '3', '3.02', '3.92', '1.67', '3.71', '3.5', '3.35', '4.08', '2.75', '2.23', '7.58', '3.18', '2.34', '2', '2', '4.3', '3', '1.45', '2.5', '3', '2.45', '3.27', '3.6', '2', '3.07', '2.31', '5', '2.24', '2.54', '3.06', '1.32', '5.6', '3', '5', '6', '2.05', '3', '2.5', '2.6', '5.2', '1.56', '4.34', '3.51', '3', '1.5', '1.76', '6.73', '3.21', '2', '1.98', '3.76', '2.64', '3.15', '2.47', '1', '2.01', '2.09', '1.97', '3', '3.14', '5', '2.2', '1.25', '3.08', '4', '3', '2.71', '3', '3.4', '1.83', '5', '2.03', '5.17', '2', '4', '5.85', '3', '3', '3.5', '1', '4.3', '3.25', '4.73', '4', '1.5', '3'],
    'sex':['F', 'M', 'M', 'M', 'F', 'M', 'M', 'M', 'M', 'M', 'M', 'F', 'M', 'M', 'F', 'M', 'F', 'M', 'F', 'M', 'M', 'F', 'F', 'M', 'M', 'M', 'M', 'M', 'M', 'F', 'M', 'M', 'F', 'F', 'M', 'M', 'M', 'F', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'F', 'F', 'M', 'M', 'M', 'M', 'F', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'F', 'F', 'M', 'M', 'M', 'F', 'F', 'F', 'F', 'M', 'M', 'M', 'M', 'M', 'M', 'M', 'F', 'M', 'M', 'F', 'M', 'M', 'M', 'M', 'M', 'M', 'F', 'F', 'F', 'M', 'M', 'M', 'M'],
    'smoker':['N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'N', 'Y', 'N', 'Y', 'N', 'Y', 'Y', 'Y', 'Y', 'N', 'N', 'N', 'Y', 'N', 'Y', 'N', 'N', 'Y', 'Y', 'N', 'N', 'Y', 'N', 'N', 'N', 'Y', 'N', 'N', 'Y', 'N', 'N', 'N', 'N', 'N', 'N', 'Y', 'N', 'Y', 'Y', 'N', 'Y', 'Y', 'Y', 'Y'],
    'day':['Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Sunday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Saturday', 'Thursday', 'Thursday', 'Thursday', 'Thursday', 'Thursday', 'Thursday', 'Thursday', 'Thursday', 'Thursday', 'Thursday', 'Thursday', 'Thursday', 'Thursday', 'Friday', 'Friday', 'Friday', 'Friday', 'Friday', 'Friday', 'Friday', 'Friday', 'Friday'],
    'time':['Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Lunch', 'Lunch', 'Lunch', 'Lunch', 'Lunch', 'Lunch', 'Lunch', 'Lunch', 'Lunch', 'Lunch', 'Lunch', 'Lunch', 'Lunch', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner', 'Dinner'],
    'table_size':['2', '3', '3', '2', '4', '4', '2', '4', '2', '2', '2', '4', '2', '4', '2', '2', '3', '3', '3', '3', '2', '2', '2', '4', '2', '4', '2', '2', '2', '2', '2', '4', '2', '4', '2', '3', '3', '3', '3', '3', '3', '2', '2', '2', '4', '2', '2', '4', '3', '2', '2', '2', '4', '2', '4', '2', '4', '2', '2', '4', '2', '2', '2', '4', '3', '3', '2', '1', '2', '2', '2', '3', '2', '2', '2', '2', '2', '4', '2', '2', '2', '2', '1', '2', '2', '4', '2', '2', '2', '2', '2', '2', '2', '2', '2', '4', '2', '2', '2']

}
df=pd.DataFrame(data)
df

"""## **Task 2**"""

# Task 2: Print a chosen record (row) or a chosen column (data field). 
# Printing Chosen Record
print ("Please enter your row number, we have total 5 rows from 0 to 4")
chosen_record = input()
print (df.loc[int(str(chosen_record))])

# Task 2: Print a chosen record (row) or a chosen column (data field).
# Printing Chosen Column
print ("Please enter which column you want to print, total_bill, tip, sex, smoker, day, time table_size?")
chosen_column = input()
print (df[(str(chosen_column))])

# For Task 2,  We can always print the columns and rows directly using the dataframe object applying different methods like:

# 1. Slicing
# 2. iloc (used in printing record)

# Task 2.1: Slicing
df[1:2] # Prints row with index 1 (returns DataFrame)

# Task 2.2: iloc (using Labels)
df.iloc[1] # returns pandas series

"""## **Task 3**"""

# Task 3: Print rows that satisfy a condition on one of the column entries. 
# For task 3 we will print following
# 1. Total tip collected in time=='Dinner'
# 2. Maximum tip with maximum table size

df

# Task 3.1: Total tip collected in time=='Dinner'
# First find the records where time==Dinner and column==tip and then convert to list of integers

collected_tip = (df.tip[(df['time']=='Dinner')]).to_list()
collected_tip # This will print  ['1.01', '1.66', '3.31'] which is string hence need to convert
new_tips=collected_tip # storing previous list to a temporary list called new_tips (fruitful when the list is unknown size)
for i in range(0,len(collected_tip)):
  new_tips[i]=float(collected_tip[i])
print (new_tips)
print("Sum is: "+ str(sum(new_tips)))

# Task 3.2: tip with maximum table size
df['table_size'].max() # max() function returns the maximum value among the column of a dataframe.

tip_max = df.tip[df['table_size']==df['table_size'].max()] # Satisfies the condition of maximum table size in column entries
print (tip_max)

"""## **Task 4**"""

# Task 4: Also sort the records based on the total bill paid by the customer

# 1. Sort with function
# 2. Sort without function
df

# Task 4.1: with function
df.sort_values(by='total_bill')

# Task 4.2: without function 
# Aprroach will be like:
# 1. Fetch the column by which you want to sort the DataFrame
# 2. Sort the column
# 3. Fetch associated rows with each value of the column from DataFrame

# 4.2.1:
handler_column = df['total_bill']
temp_handler = handler_column
for eachitem in range (0, len(handler_column)):
  temp_handler[eachitem] = float(handler_column[eachitem])
  # print (handler_column[eachitem])

final_list = temp_handler.to_list()
# Apply sorting algorithm to the list/array now
final_list

# 4.2.2: Using Bubble sort 

preserver_list = final_list
temp_list = final_list
def bubbleSort(arr): 
    n = len(arr) 
  
    # Traverse through all array elements 
    for i in range(n): 
  
        # Last i elements are already in place 
        for j in range(0, n-i-1): 
  
            # traverse the array from 0 to n-i-1 
            # Swap if the element found is greater 
            # than the next element 
            if arr[j] > arr[j+1] : 
                arr[j], arr[j+1] = arr[j+1], arr[j] 

bubbleSort(final_list)  
print ("Sorted list is:") 
for i in range(len(final_list)): 
    # print (final_list[i])
    temp_list[i]=float(final_list[i])

temp_list

sorted_array = temp_list
print (df)
print (sorted_array)

# Task 4.2.3: Fetch associated rows with each value of the column from DataFrame (This method works for only distinct total_bill values)

# df.loc[df['total_bill']==10.34]
for item in sorted_array:
  for i in (df['total_bill']):
    if(item == i):
      print (df.loc[df['total_bill']==i])


#Phew!!!!!

"""## **Task 5 + Task 6**"""

# Task 5: Use vectorised operations. 
# For example, you may be required to compute the percentage runs scored by each player, 
# where the percentage is with respect to the total runs scored by the team in an innings. 
df
# In our case we can compare percentage ratio of total bill versus tip given. 
# We can add a new column once calculated for each customer

# df['tip/bill']=(df['tip']/df['total_bill'])*100
df['tip/bill'] = df['tip'] # Just to initialize the DataFrame of size same with the dataset
rows_count=df.shape[0] # Gives row count
for x in range (0,rows_count):
  percentage = (float(df.tip[x])/df.total_bill[x])*100
  df['tip/bill'][x]=float(percentage)
  print (percentage)

df # Task 6 Addedd a new column to DataFrame namely tip/bill

"""## **Task 7**"""

# Task 7: Export the Dataframe to a file in pickle format and save it as a file.  Read the pickle file back to the program.

df.to_pickle("./assignment2.pkl") # to_pickle saves the df as pkl file
read_df = pd.read_pickle("./assignment2.pkl") # reads the pkl file and unload it to a dataframe object
read_df

"""## **Task 8** + **Task 9**"""

# Task 8+9: Use matplotlib library to make a scatter plot of columns that contain numeric
# In our example, we can make a scatter plot as x-asis for total bill and y axis as tip and vice versa.
# Also printing labels
import matplotlib.pyplot as plt

# Task 8.1: x-axis: total_bill , y-axis: tip
plt.scatter(df['total_bill'],df['tip'])
plt.xlabel("total bill") 
plt.ylabel("tip")

# Task 8.2: y-axis: total_bill , x-axis: tip
plt.scatter(df['tip'],df['total_bill'])
plt.xlabel("tip") 
plt.ylabel("total bill")

"""### **Task 10**"""

# Task 10:Implement linear regression to model the dependency 
# between two variables - the predictor x and target y. You can choose any two 
# columns in your data frame as the two variables. 

# Print the coefficients obtained from linear regression and plot the straight line on the scatter plot.  

# Do not use any inbuilt function for implementing linear regression.  

# You need to formulate a linear system of equations and solve them using pseudo inverse.  

# You can compare your result with that produced by the fit() 
# function of LinearRegression model in sklearn. 

df

# Choosing total_bill and tip as two variables.

# Let us again plot tip vs total_bill
plt.scatter(df['total_bill'],df['tip'], marker='+')
plt.xlabel("total bill") 
plt.ylabel("tip")

# Print the coefficients obtained from linear regression and plot the straight line on the scatter plot.  

# convert all stuff to float

predictorX = df['total_bill']
for datax in range (0,len(df['total_bill'])):
  predictorX[datax]=float(df['total_bill'][datax])
# print (predictorX)

targetY = df['tip']
for datay in range (0,len(df['tip'])):
  targetY[datay]=float(df['tip'][datay])
# print (predictorX)
# print (targetY)
X = predictorX
Y = targetY

"""---



---


This is using 
# Using inverse
from numpy.linalg import inv

inv(X^T * X) * X^T * y (Inverse Method)

This is prone to the matrix which is non invertible.
"""

# Print the coefficients obtained from linear regression and plot the straight line on the scatter plot.  

# convert all stuff to float
import numpy as np
predictorX = df['total_bill']
for datax in range (0,len(df['total_bill'])):
  predictorX[datax]=float(df['total_bill'][datax])
# print (predictorX)

targetY = df['tip']
for datay in range (0,len(df['tip'])):
  targetY[datay]=float(df['tip'][datay])
# print (predictorX)
# print (targetY)
X = predictorX
Y = targetY

# Using inverse
from numpy.linalg import inv
X = X.to_numpy(dtype=np.float).reshape((-1,1))
b = inv(X.T.dot(X)).dot(X.T).dot(Y) # Least squares inv(X^T * X) * X^T * y (Inverse Method)
#  This is prone with the matrix being non invertible. 
print(b)
ycap = X.dot(b)
plt.scatter(X, Y)
plt.plot(X, ycap, color='red')
plt.xlabel("total bill") 
plt.ylabel("tip")
plt.xlim(8,30)
plt.ylim(0,5)
plt.show()

"""---



---


This is using 

# Pseudo Inverse

from numpy.linalg import pinv

b = pinv(X).dot(Y) # Pseudo Inverse

![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAK4AAAAaCAYAAAAuV2eNAAAEQElEQVR4Ae2biVHkMBBFJwRiIARiIARiIARiIARiIARiIARiIIXZeip90yNrbGncsj3WbtWUdfb1v1oHtaeHh4fz6XQKP8o1P83Lfb++vpD5/1/jCHSL38fHx0Dc5+fnm8j28/NzRs7Ly8tiWY1xPj09PZ3f3t6CvfjLD9vf39/Pj4+PN/nf2uYp+b3hdxGLSNhAuhiIi/6ayu/v7/n19TXIgtA1c1uPZRewO4FIK70QWuV7+vaC3wgTyGa3HA/CfX5+isAjfVs1pIsSn62v2LyVbUv09oJfNkYxE4VM6bVlksEIalbhxo0QNi7WjS3xUd8bfhdRi1tlIG/c7i/6j1Qh+8Yt9jBu9YTfCDQuL3oluNetc+RUpoGLJBeyTNddN/WC3wikFuelkZIdNHAc+v7+Phxxe8EvS6GYaUPmjSs4O+5eG+O5+3CkFR5Hx09+Zr960uLY0OqZiAsFQUYXlyXqnD2p33KpK5GHfI4JXMwo1+ghQ8teGzTsjWQ5KePZ1wo7dq1ya/yuxSIXnxKfS7ArkRPGxNeFkHkRXDyxYKAcZyhl+6aK3lp93vJSFyCkyJkeM1gE6Nccdqkp+yEVi6fktyRptMLPxiL1HRxr7w7u2MWsEYiLgTXZSSBe+1rnIuiDfDKhnQdh0jbbT7lGXjq3pC4impiEaWldtmydcbHD2BZ2GC/8FAvhZuOXEtkbuxJ5wZ5ImEBeMoQ10qsM6Txle8uzfpIBra3EJ31Wm1tkVl7rckv80ljkiFzrnyt2Eahhq6w1Zm48W6u24bmxJf1z8opXbUZZeowhNjbbM2VPxMWeVvilsSAO6SLOhHCyaQ67yclpJ8KWnLVSedS13Wg7s9uYJQIksBkuJ6tG3rX5Fe3DkYY5KXj4EzPPVZFrnXFlQAv8Il4XsUjPt97YlcoLfkOaEuIoSCVfDIgXh5CdKIu49Ol8SBl5tp86/dhk55TIK7FNY1IdaucMJ/vQT93uFrJZ47f+tsDP+DQcHWNMhkWrOHhhd02eseWvSOZjtf61+JRwkgwO4JTJvqqn2Yr+1AbGWALVyCMAJQsx1SHPsZWMiRx+jEMeZeKlxaTxW35b4Sef8Bnc9I1/cVV3SDCe2OW4MChTAVKlq0V9a34VGA+dBBg5e/DLw58pGWvjxyKJb8eDWZ7YIXRW3rVsM1i0YkEkE+mWqi5atUuVbDx/DfzIpLqn4K7dAeW+N3aT8gAWI6xRMmSLr7Zl7PLQP7tqPZRsKGMt/OxxSxilbqvdC7tJebDaK7tBktSZreuTq3Zr4xz0r4UfHOHHEcFeTh1cqBfBc4YX2XCKFVJvRdsZk6u2rerm0nvAbxREAF36eIxQbtWRsLs5boycPWBDl/jd+mwCSTm/cB4mw0bik2XDOfmA/NilS13iFy9hgWz6nw8eX68jxy6ZsiOjusVP729sNZ6/PT3E74hn7qb0it8/PsNuJmrP/BcAAAAASUVORK5CYII=)
"""

# Print the coefficients obtained from linear regression and plot the straight line on the scatter plot.  

# convert all stuff to float
# import numpy as np
from numpy.linalg import pinv
predictorX = df['total_bill']
for datax in range (0,len(df['total_bill'])):
  predictorX[datax]=float(df['total_bill'][datax])
# print (predictorX)

targetY = df['tip']
for datay in range (0,len(df['tip'])):
  targetY[datay]=float(df['tip'][datay])
# print (predictorX)
# print (targetY)
X = predictorX
Y = targetY

# Using pseudo inverse
from numpy.linalg import inv
X = X.to_numpy(dtype=np.float).reshape((-1,1))
# b = inv(X.T.dot(X)).dot(X.T).dot(Y) # Least squares inv(X^T * X) * X^T * y (Inverse Method) 
b = pinv(X).dot(Y) # Pseudo Inverse
print(b)
yhat = X.dot(b)
plt.scatter(X, Y)
plt.plot(X, yhat, color='red')
plt.xlabel("total bill") 
plt.ylabel("tip")
plt.xlim(8,30)
plt.ylim(0,5)
plt.show()

"""## **Basic Approach for calculating Linear Regression without function.**"""

X = df['total_bill']
tab = pd.DataFrame()
tab['X']=X
tab['Y']=Y
tab
# for x in range (0,rows_count):
#   percentage = (float(df.tip[x])/df.total_bill[x])*100
#   df['tip/bill'][x]=float(percentage)
#   print (percentage)
# plt.plot(X,Y)

tab['XY']=tab['X'] # Just to initializae with the same size
for each in range(0, tab.shape[0]):
  product = float(tab.X[each]) * float(tab.Y[each])
  tab['XY'][each]=float(product) # writing the actual values
  print(product)

tab

tab['X2']=tab['X'] # Just to initializae with the same size
for each in range(0, tab.shape[0]):
  square = float(tab.X[each]) * float(tab.X[each])
  tab['X2'][each]=float(square) # writing the actual values
  # print(square)


tab['Y2']=tab['X'] # Just to initializae with the same size
for each in range(0, tab.shape[0]):
  square = float(tab.Y[each]) * float(tab.Y[each])
  tab['Y2'][each]=float(square) # writing the actual values
  # print(square)

tab

"""Line : Y=a+bX

![image.png](data:image/png;base64,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)
"""

# now that we have X, Y, XY, X2, Y2 we need sum of each of them total sum so that we can further calculate coefficients

sigmaX = sum(tab['X'])
sigmaY = sum(tab['Y'])
sigmaXY = sum(tab['XY'])
sigmaX2 = sum(tab['X2'])
sigmaY2 = sum(tab['Y2'])

# Find a

num_a = (sigmaY*sigmaX2)-(sigmaX*sigmaXY)
denom_a = (5*(sigmaX2))-((sigmaX)**2)
a = num_a/denom_a
print (a)

# Find b
num_b = (5*sigmaXY)-(sigmaX*sigmaY)
denom_b = (5*sigmaX2)-(sigmaX**2)
b=num_b/denom_b
print(b)

"""EQUATION OF LINE: y= -0.09462 + 0.15640x"""

# y = a + b*X

# PLEASE NOTE THAT y is our preictor and Y is our dataframe for Y values
# PLEASE NOTE THAT y is our preictor and Y is our dataframe for Y values
# PLEASE NOTE THAT y is our preictor and Y is our dataframe for Y values

y= -0.09462 + 0.15640*X
plt.plot(X, y, color='#58b970', label='Regression Line')
plt.scatter(X,Y,color='#ef5423', label='Scatter Plot')
plt.xlabel('Billing amount')
plt.ylabel('Tip given')
plt.legend()
plt.show()

"""## Using Builtin Function"""

from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
X = df['total_bill'].values.reshape(-1,1)
# reshaping (5,7) to (35,1) to solve in one dimension
reg = LinearRegression()
reg =reg.fit(X,y)
y_target = reg.predict(X)

y_target

plt.plot(X,y_target,color='#58b970', label='Regression Line')
plt.scatter(X,Y,color='#ef5423', label='Scatter Plot')
plt.xlabel('Billing amount')
plt.ylabel('Tip given')
plt.legend()
plt.show()

"""END"""